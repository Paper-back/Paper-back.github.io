<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo博客搭建</title>
    <url>/2021/05/26/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="git-clone-出现fatal-unable-to-access-‘https-github-类错误解决方法"><a href="#git-clone-出现fatal-unable-to-access-‘https-github-类错误解决方法" class="headerlink" title="git clone 出现fatal: unable to access ‘https://github 类错误解决方法"></a>git clone 出现fatal: unable to access ‘<a href="https://github/">https://github</a> 类错误解决方法</h2><p>将命令行里的http改为git重新执行。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>城市与记忆之三</title>
    <url>/2021/05/25/%E5%9F%8E%E5%B8%82%E4%B8%8E%E8%AE%B0%E5%BF%86%E4%B9%8B%E4%B8%89/</url>
    <content><![CDATA[<p>描述我现在居住的城市有一种方法。你可以说，城墙上高耸的金属建筑物，他们锈迹斑斑，向来这里的赶路人说这并不是我的全部；城中几座刚不久被翻新的钢索桥横跨这条江，河水流进四周的村落，主干穿过城市的主体。在<span id="more"></span>很多人的想象中，这座城市是为了这一江水而诞生的，在它出现之前之后，河水永远从接近天边的天花石上顺流而下，随着时间的流动，只不过沿途多了几处建筑，一些人罢了。不同的是，这个地方越来越多的少女会嫁给其他地方的小伙子，但每当谈及这里，她们的笑容里充满幸福：曾经在冬月的黄昏到来、白昼渐短的时候，她们曾在落寞的街头享受过一餐盛宴并且彼时感到快乐。</p>
]]></content>
      <categories>
        <category>读的见的城市</category>
      </categories>
  </entry>
  <entry>
    <title>城市与记忆 之一</title>
    <url>/2021/05/22/%E5%9F%8E%E5%B8%82%E4%B8%8E%E8%AE%B0%E5%BF%86%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<p>一直在相同的路上行走，目光艰难聚集在一个物体上，身旁全都是石头和树木，只是在认出一处事物能表明另一个事物、另一个故事和感悟时才会驻目观察。草坪上的足迹说明人来人往，一条狭长水道的泥沼说明一脉水源相通；梨花意味着冬季的结束。其余的一切都寂静无声，可以相互感知。石头和树木只是石头和树木。</p>
<hr>
]]></content>
      <categories>
        <category>读的见的城市</category>
      </categories>
  </entry>
  <entry>
    <title>城市与记忆 之二</title>
    <url>/2021/05/25/%E5%9F%8E%E5%B8%82%E4%B8%8E%E8%AE%B0%E5%BF%86%E4%B9%8B%E4%BA%8C/</url>
    <content><![CDATA[<p>我的老友们，无论我怎样努力，都难以描述出那座落在迷踪森林中的城市。我可以告诉你，铺在崎岖小路上的青石板有多少块，高低起伏的街道有多少级台阶，每一间小屋上瓦片的颜色和数量。但是，这其实等于什么都没告诉你。令我流连忘返的不是这些，而是她的每一草一木与曾经往事之间的联系：</p>
<span id="more"></span>

<p>太阳在天空中位置的变化，哭泣的姑娘滴在叶片上的泪珠，她在埋怨深爱的男孩，远处轨道驶过的火车突然轰鸣的程度和人们梦中惊醒的恼怒，飘动在锅灶和木柴之间忽明忽暗的火苗的燃烧和围在火炉旁人们冰凉的手掌。</p>
<p>卡尔维诺告诉我，”这地方像一块海绵，吸汲着这些不断涌流的记忆的潮水，并随之膨胀着。这些过去被像手纹一样藏起来，它被写在青石板街道的角落，窗口的护栏，楼梯的扶手上。” 除非时光倒流，太阳西升东落，泪水凝固，炊烟消尽，这些痕迹永远在这里。</p>
]]></content>
      <categories>
        <category>读的见的城市</category>
      </categories>
  </entry>
  <entry>
    <title>链表-递归</title>
    <url>/2021/05/27/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>总结涉及到递归算法的链表相关基础题</p>
<h2 id="两两交换链表中的结点"><a href="#两两交换链表中的结点" class="headerlink" title="两两交换链表中的结点"></a>两两交换链表中的结点</h2><blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<p><img src="../images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/swap_ex1.jpg"></p>
</blockquote>
<h3 id="解1：非递归–多指针"><a href="#解1：非递归–多指针" class="headerlink" title="解1：非递归–多指针"></a>解1：非递归–多指针</h3><p>设置pre指针，实现由temp-start-end到temp-end    start-end.next    ，后重置指针temp的位置即可</p>
<p>画解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置哨兵指针pre</span></span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        pre.next = head; </span><br><span class="line">        <span class="comment">//指针1 temp</span></span><br><span class="line">        ListNode temp = pre;  </span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//指针2 start</span></span><br><span class="line">            ListNode start = temp.next; </span><br><span class="line">            <span class="comment">// 指针3 end</span></span><br><span class="line">            ListNode end = temp.next.next; </span><br><span class="line">            <span class="comment">//实现两两交换</span></span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;  </span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解-2：递归"><a href="#解-2：递归" class="headerlink" title="解 2：递归"></a>解 2：递归</h3><p>递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，我们应该关注一级调用小单元的情况，也就是单个f(x)。</p>
<p>其中我们应该关心的主要有三点：</p>
<p>1.返回值 </p>
<p>2.调用单元做了什么</p>
<p>3.终止条件</p>
<p>在本题中：</p>
<p>返回值：交换完成的子链表        </p>
<p>调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head（<strong>即所说的不断重复的事</strong>）</p>
<p>完成交换终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换</p>
<p>画解：</p>
<p><img src="../images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/%E9%93%BE%E8%A1%A8%E4%BA%A4%E6%8D%A2.png"></p>
<p><img src="../images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B-1622117404317.png"></p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件 递归至最后一个执行单元</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//第一个返回值</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每一个小执行单元的过程</span></span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="comment">//返回结果，意义与终止条件中 head相同</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="合并两个有序列表"><a href="#合并两个有序列表" class="headerlink" title="合并两个有序列表"></a>合并两个有序列表</h2><blockquote>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><img src="../images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/merge_ex1.jpg"></p>
</blockquote>
<h3 id="解1：迭代合并"><a href="#解1：迭代合并" class="headerlink" title="解1：迭代合并"></a>解1：迭代合并</h3><p>设置prev指针，通过比较l1和l2的值来调整prev的next指针，随后将prev向后移动一位，循环结束后，直接将非空的一条链表接在后面即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置哨兵指针</span></span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode prev = prehead;</span><br><span class="line">        <span class="comment">//循环迭代</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//prev指针后移</span></span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后接非空的链表</span></span><br><span class="line">        prev.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解2：递归"><a href="#解2：递归" class="headerlink" title="解2：递归"></a>解2：递归</h3><blockquote>
<p>再次强调：递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。<strong>我们应该关注一级调用小单元的情况。</strong></p>
<p><strong>其中我们应该关心的主要有三点：</strong></p>
<p>1.返回值 </p>
<p>2.调用单元做了什么</p>
<p>3.终止条件 </p>
</blockquote>
<p>在本题中:</p>
<p>返回值：合并完成的链表</p>
<p>调用单元：比较l1.val 和l2.val的大小，将小的连接已经合并完的链表</p>
<p>终止条件：l1和l2中有一条为空</p>
<p>画解：</p>
<p><img src="../images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/%E5%90%88%E5%B9%B6.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件和第一个返回值</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>342+465=907:</p>
<p><img src="../images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/addtwonumber1.jpg"></p>
</blockquote>
<h3 id="解1：普通解"><a href="#解1：普通解" class="headerlink" title="解1：普通解"></a>解1：普通解</h3><p>思路：设置两个存放结点值的和一个存放进位值的变量，头节点计算时没有进位值，链表对应位置为空视为存放的值为零。创建新链表，<strong>每个结点的值为sum%10，并传递进位制sum/10</strong>，直到两个链表都循环至空，此时如果还有进位值，需再创建一个结点存放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//准备新链表的指针</span></span><br><span class="line">       ListNode head = <span class="keyword">null</span>,cur = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(l1!= <span class="keyword">null</span>||l2!= <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//链表对应位置为空视为存放的值为零</span></span><br><span class="line">           <span class="keyword">int</span> n = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">           <span class="keyword">int</span> m = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">           <span class="comment">//两个值与进位值的和</span></span><br><span class="line">           <span class="keyword">int</span> sum = n+m + inc;</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//创建新链表，head和cur同时指向头结点</span></span><br><span class="line">               head = cur = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//调整cur指针，每个结点值为sum%10</span></span><br><span class="line">               cur.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>); </span><br><span class="line">               cur = cur.next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//进位值</span></span><br><span class="line">           inc = sum/<span class="number">10</span>;</span><br><span class="line">           <span class="comment">//迭代进行下一位</span></span><br><span class="line">           <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//如果还有进位值，需再创建一个结点存放</span></span><br><span class="line">       <span class="keyword">if</span>(inc != <span class="number">0</span>)&#123;</span><br><span class="line">           cur.next =  <span class="keyword">new</span> ListNode(inc);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回新链表</span></span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解2：递归-1"><a href="#解2：递归-1" class="headerlink" title="解2：递归"></a>解2：递归</h2><p>效率高但并没有简洁许多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//记录进位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义终止条件，当l1,l2指针都为null时且进位为0 -&gt;null</span></span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>&amp;&amp;carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当有一条链表为null 且 进位为0时，next指针直接指向另外一条链表返回</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>&amp;&amp;carry==<span class="number">0</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>&amp;&amp;carry==<span class="number">0</span>) <span class="keyword">return</span> l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sum = 两链表指针位置上的数字加上进位</span></span><br><span class="line">        <span class="keyword">int</span> sum = (l1==<span class="keyword">null</span>?<span class="number">0</span>:l1.val)+(l2==<span class="keyword">null</span>?<span class="number">0</span>:l2.val)+carry;</span><br><span class="line">        <span class="comment">//计算进位 </span></span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//计算链表的value</span></span><br><span class="line">        <span class="keyword">int</span> value = sum % <span class="number">10</span>;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归算出这个node的next指向</span></span><br><span class="line">        node.next = addTwoNumbers((l1==<span class="keyword">null</span>?<span class="keyword">null</span>:l1.next),(l2==<span class="keyword">null</span>?<span class="keyword">null</span>:l2.next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
</search>
