<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>equals方法与相等测试 hashcode toString方法</title>
    <url>/2021/10/16/equals%E6%96%B9%E6%B3%95%E4%B8%8E%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95-hashcode-toString%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="equals方法与相等测试-hashcode-toString方法"><a href="#equals方法与相等测试-hashcode-toString方法" class="headerlink" title="equals方法与相等测试 hashcode toString方法"></a>equals方法与相等测试 hashcode toString方法</h2><h3 id="equals方法与相等测试"><a href="#equals方法与相等测试" class="headerlink" title="equals方法与相等测试"></a>equals方法与相等测试</h3><p>object类中的equals方法用于检测一个对象是否等于另一个对象。object类中实现它时效果等同于==操作符：确定两个对象引用是否相等。不过，在许多情况下，经常需要基于两个对象的状态检测其相等性，如果两个对象有相等的状态，则认为两个对象是相等的。<br>下面具体讨论调用equals方法进行相等测试的具体操作：</p>
<span id="more"></span>

<p>**首先需要明确，equals方法是个覆盖方法，签名要与object类中原方法相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Emloyee</span></span></span><br><span class="line"><span class="class"></span>&#123;  <span class="comment">//显式参数类型是Empioyee，没有覆盖object类中原方法，而是定义了一个无关的方法。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Employee other)</span></span>&#123; ...&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object other)</span></span>&#123; ...&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们用员工示例展示equals方法的实现机制（如果两个员工对象的姓名，薪水和雇佣日期都一样，就认为它们是相等的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">// 首先检查两个对象引用是否相同</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 如果显参引用为null，返回false</span></span><br><span class="line">      <span class="keyword">if</span> (other0bject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 如果两个对象不属于同一个类，必然不相等，返回false</span></span><br><span class="line">   <span class="number">1.</span> <span class="keyword">if</span> (getClass() != other0bject.getClass())</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 现在我们知道otherObject是一个非空Emloyee </span></span><br><span class="line">      Employee other=(Employee) otherObject;</span><br><span class="line">      <span class="comment">// 检测两个对象的状态是否相同</span></span><br><span class="line">   <span class="number">2.</span><span class="comment">// return name.equals(other.name) </span></span><br><span class="line">   <span class="number">3.</span> <span class="keyword">return</span> Object.equals(name,other.name)</span><br><span class="line">         &amp;&amp;salary == other.salary</span><br><span class="line">         &amp;&amp; Object.equals(other.hireDay);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该过程中有几个值得讨论的方面。</p>
<ol>
<li>如果隐式和显式参数不属于同一个类，equals的处理方式是个存在争议的问题。在上例中，<strong>getClass方法返回一个对象所属的类</strong>，如果发现类不匹配会返回就会false。但是，我们经常也会见到使用instanceof进行检测：<br><code>if(!(otherObject instanceof Empoyee) return false;)</code><br>这种方式允许otherObject属于一个子类。随着介绍使用instanceof的麻烦和方便之处：</li>
</ol>
<ul>
<li>Java语言规范要求equals方法具有<strong>对称性：对于任何引用x和y，当且仅当<code>y.equals(x)</code>返回true时，<code>x.equals(y)</code>返回true。</strong> 这当然很合理，你肯定不希望类库实现者一直需要纠结调用<code>y.equals(x)</code>还是<code>x.equals(y)</code>的问题。但是，当参数不属于同一个类的时候会对这个规则产生一些束缚。比如：e是Employee对象，m是一个Manager对象<br><code>e.equals(m)</code>如果用instanceof检测返回true的话，意味着反过来调用：<br><code>m.equals(e)</code>也需要返回true，这就对Manager类受到了束缚，它的equals方法可以将自己与任何一个Employee对象进行比较，而不考虑经理特有的信息。</li>
<li>在有些情况下，在超类决定相等性概念，子类的对象可以据此进行相等性比较时，instanceof方法则更合适。比如集合：TreeSet 和 Hashset都是AbstactSet的具体子类，只是运用了不同的算法来查找集合元素，无论如何，你肯定希望能够任意比较两个集合。此时getClass就显得有问题，它违反了<strong>替换原则</strong>。</li>
</ul>
<ol start="2">
<li>为了防备name或hireDay可能为null的情况，不直接采用<br><code>return name.equals(other.name)</code>需要使用Objects.equals方法：<blockquote>
<p>如果两个参数都为null，Objects.equals(a，b)调用将返回true；如果其中一个参数为null，<br>则返回false；否则，如果两个参数都不为null，则调用a.equals(b)。因为比较的是引用变量，a.equals(b)和a==b作用相同</p>
</blockquote>
</li>
</ol>
<hr>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>散列码（hash code）是由对象导出的一个整形值。equals相同，hashCode方法也定义在Object类中，子类可以覆盖此方法。<br>String类使用的用于散列码的算法是由<strong>内容</strong>导出的。<br>字符串构造器<code>var t = new String(&quot;...&quot;) </code>的散列码计算方式则不同。因为StringBuilder类中没有定义覆盖hashCode方法，而<strong>Object类的默认hashCode方法是从对象的存储地址得出散列码</strong><br>在调用hashCode方法时应注意以下几点：</p>
<ol>
<li>如果重新定义了equals方法，就必须重新定义hashCode方法。equals与hashCode的定义必须相同：如果x.equals(y)返回ture，那么x.hashCode()与y.hashCode()返回值相同。</li>
<li>最好使用null安全的方法Object.hashCode（），如果参数为null，该方法会返回0。</li>
</ol>
<hr>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3>]]></content>
      <categories>
        <category>Javase笔记</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客搭建</title>
    <url>/2021/05/26/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="git-clone-出现fatal-unable-to-access-‘https-github-类错误解决方法"><a href="#git-clone-出现fatal-unable-to-access-‘https-github-类错误解决方法" class="headerlink" title="git clone 出现fatal: unable to access ‘https://github 类错误解决方法"></a>git clone 出现fatal: unable to access ‘<a href="https://github/">https://github</a> 类错误解决方法</h2><p>将命令行里的http改为git重新执行。</p>
<hr>
<h2 id="hexo-typora博客插入图片"><a href="#hexo-typora博客插入图片" class="headerlink" title="hexo + typora博客插入图片"></a>hexo + typora博客插入图片</h2><p>事先声明，所有博客文件均保存在 hexo/_posts/文件夹下</p>
<p>首先在 hexo &gt; source目录下建一个文件夹叫images，用来保存博客中的图片。</p>
<p>然后打开Typora的 文件 &gt; 偏好设置，进行如下设置。</p>
<p><img src="/images/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/2019090318384447.png"></p>
<p>这样的话所有的博客中的图片都将会保存到 /source/images/该博客md文件名/图片名称</p>
<p>但是仅仅这样设置还不够，这样设置在typora中倒是能看图片了，但是使用的却是相对于当前md文件的相对路径，可是如果启动hexo，是要用服务器访问的，而服务器显然无法根据这个相对路径正确访问到图片，因此还需要在typora中进行进一步设置。</p>
<p>在typora菜单栏点击 格式-&gt;图像-&gt;设置图片根目录，将hexo/source作为其根目录即可。</p>
<p>一定要先设置了图片根目录后再插入图片，否则图片路径会不正确.</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>创建线程的方式</title>
    <url>/2021/07/13/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>JAVA语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来实现。</p>
<p><strong>Thread的特性</strong></p>
<blockquote>
<p>1.每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为<strong>线程体</strong>。</p>
<p>2.通过该Thread对象的start()方法来调用这个线程</p>
</blockquote>
<span id="more"></span>

<h2 id="创建线程的两种方式"><a href="#创建线程的两种方式" class="headerlink" title="创建线程的两种方式"></a>创建线程的两种方式</h2><p><strong>因为线程由Thread对象的run方法来完成操作，所以涉及其构造方法</strong></p>
<blockquote>
<p>Thread():创建新的Thread对象</p>
<p>Thread(String threadname):创建线程并指定线程实例名</p>
<p>Thread(Runnable target):指定创建线程的目标对象，它实现Runnable接口的run方法</p>
<p>Thread(Runnable target,String name):创建新的Thread对象</p>
</blockquote>
<p>下面两种方式利用不同的构造方法创建线程。</p>
<h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><ul>
<li><ol>
<li>定义子类继承Thread类</li>
</ol>
</li>
<li><ol start="2">
<li>子类重写Thread类中的**run()**方法</li>
</ol>
</li>
<li><ol start="3">
<li>创建Thread子类的对象实例，即同时创建了<strong>线程对象</strong></li>
</ol>
</li>
<li><ol start="4">
<li>调用线程对象start()方法，即启动线程，调用run()方法</li>
</ol>
</li>
</ul>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><ul>
<li><ol>
<li>定义子类，实现Runnable接口</li>
</ol>
</li>
<li><ol start="2">
<li>子类中重写Runnable接口种的**run()**方法</li>
</ol>
</li>
<li><strong>3) 通过Thread类含参构造器创建线程对象</strong></li>
<li><strong>4) 将Runnable接口的子类对象作为实参传递给Thread类的构造方法</strong></li>
<li><ol start="5">
<li>调用线程对象start()方法，即启动线程，调用<strong>Runnable子类接口</strong>的run()方法</li>
</ol>
</li>
</ul>
<p><em>代码实现</em></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>动态绑定强制转换抽象类</title>
    <url>/2021/10/14/%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="动态绑定强制转换抽象类"><a href="#动态绑定强制转换抽象类" class="headerlink" title="动态绑定强制转换抽象类"></a>动态绑定强制转换抽象类</h2><hr>
<h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><p>清楚编译器的绑定机制对准确地理解如何在对象上应用方法调用十分重要。假设调用<code>x.f(args)</code>，隐式参数x是类C的一个对象。下面是调用过程的详细描述：</p>
<ol>
<li>首先编译器查看对象地编译类型（声明类型）和方法名。包括C类中所有名为f的重载的方法和C的超类中的f方法。此时，<strong>编译器知道所有可能被调用的方法</strong></li>
</ol>
<ul>
<li>注释： 方法的名字和参数列表成为方法的标签，若子类中定义了一个与超类标签相同的方法，那么子类的该方法就会覆盖超类的方法。需要注意的是<strong>返回类型不是签名的一部分</strong>，允许子类的方法的返回类型为超类中同签名方法返回类型的子类型，依然覆盖。</li>
</ul>
<ol start="2">
<li><p>接着，编译器确定方法调用中提供的参数类型，选择一个完全方法表中完全匹配的方法。此时，<strong>编译器知道需要调用的方法的名字与参数类型</strong>（即标签）。</p>
<span id="more"></span></li>
<li><p>如果是private方法，static方法，final方法或者构造器，编译器可以准确地知道应该调用哪个方法，称为<strong>静态绑定</strong>。</p>
</li>
</ol>
<ul>
<li>注释：private方法，static方法，final方法或构造器，这类方法在程序运行之前就已经根据声明类型确定，比如static方法，它属于类，在运行期间是不可变的。</li>
</ul>
<ol start="4">
<li>与静态绑定对应，如果要调用的方法依赖于隐式参数的实际类型，则必须使用<strong>动态绑定</strong>，即首先获取实际类型的<strong>方法表</strong>，在方法中查找要调用的方法，如没有匹配将在运行类型的超类的方法表中寻找，以此类推。</li>
</ol>
<hr>
<p>###强制类型转换</p>
<blockquote>
<p>进行强制类型转换的唯一原因是：要在暂时忽略对象的实际类型后使用对象的全部功能。</p>
</blockquote>
<p>比如private，static方法。<br>如果将一个子类的引用赋给一个超类的变量，是允许的（多态），但将一个超类的引用赋给一个子类的变量，就承诺过多，必须进行强制类型转换。在进行强制类型转换之前，先查看是否能够成功地转换，为此需要使用instanceof操作符就可以实现。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(staff[<span class="number">1</span>] <span class="keyword">instanceof</span> Manager)</span><br><span class="line">&#123;</span><br><span class="line">   boss = (Manager) staff[<span class="number">1</span>];</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在继承层次结构上，位于上层的类更具有一般性，超类的几个子类可以很轻松实现某个方法的描述，而更具有一般性的超类的这个方法，则有时只需要提供一个空壳即可，使用abstract关键字，就完全不需要实现这个方法了<br><code>public abstract String getDescription();</code><br>为了提高程序的清晰度，包含<strong>抽象方法</strong>的类本身必须被声明为抽象的。<br><code>public abstract class Person &#123;    ...    public abstract String getDescription(); &#125; </code></p>
<ol>
<li>抽象类中的抽象方法只在子类中具体实现（重写），如果子类中留存抽象类的部分抽象方法没有具体实现，则该子类也将标记为抽象类。</li>
<li>即使不含抽象方法，也可以将类声明为抽象类。</li>
<li>抽象类不能实例化，但可以定义一个抽象类的<strong>对象变量</strong>，但这样的一个变量只能引用非抽象子类的对象。<code>Person p = new Student(...)</code></li>
<li>调用p.getDescription()；这看起来是调用一个没有定义的方法，但其实，由于不能构造抽象类Person的对象，所以变量p永远不糊引用Person对象，而是引用具体子类的对象，上例为Student的对象。</li>
</ol>
]]></content>
      <categories>
        <category>Javase笔记</category>
      </categories>
  </entry>
  <entry>
    <title>城市与记忆 之一</title>
    <url>/2021/05/22/%E5%9F%8E%E5%B8%82%E4%B8%8E%E8%AE%B0%E5%BF%86%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<p>一直在相同的路上行走，目光艰难聚集在一个物体上，身旁全都是石头和树木，只是在认出一处事物能表明另一个事物、另一个故事和感悟时才会驻目观察。草坪上的足迹说明人来人往，一条狭长水道的泥沼说明一脉水源相通；梨花意味着冬季的结束。其余的一切都寂静无声，可以相互感知。石头和树木只是石头和树木。</p>
<hr>
]]></content>
      <categories>
        <category>读的见的城市</category>
      </categories>
  </entry>
  <entry>
    <title>城市与记忆之三</title>
    <url>/2021/05/25/%E5%9F%8E%E5%B8%82%E4%B8%8E%E8%AE%B0%E5%BF%86%E4%B9%8B%E4%B8%89/</url>
    <content><![CDATA[<p>描述我现在居住的城市有一种方法。你可以说，城墙上高耸的金属建筑物，他们锈迹斑斑，向来这里的赶路人说这并不是我的全部；城中几座刚不久被翻新的钢索桥横跨这条江，河水流进四周的村落，主干穿过城市的主体。在<span id="more"></span>很多人的想象中，这座城市是为了这一江水而诞生的，在它出现之前之后，河水永远从接近天边的天花石上顺流而下，随着时间的流动，只不过沿途多了几处建筑，一些人罢了。不同的是，这个地方越来越多的少女会嫁给其他地方的小伙子，但每当谈及这里，她们的笑容里充满幸福：曾经在冬月的黄昏到来、白昼渐短的时候，她们曾在落寞的街头享受过一餐盛宴并且彼时感到快乐。</p>
]]></content>
      <categories>
        <category>读的见的城市</category>
      </categories>
  </entry>
  <entry>
    <title>城市与记忆 之二</title>
    <url>/2021/05/25/%E5%9F%8E%E5%B8%82%E4%B8%8E%E8%AE%B0%E5%BF%86%E4%B9%8B%E4%BA%8C/</url>
    <content><![CDATA[<p>我的老友们，无论我怎样努力，都难以描述出那座落在迷踪森林中的城市。我可以告诉你，铺在崎岖小路上的青石板有多少块，高低起伏的街道有多少级台阶，每一间小屋上瓦片的颜色和数量。但是，这其实等于什么都没告诉你。令我流连忘返的不是这些，而是她的每一草一木与曾经往事之间的联系：</p>
<span id="more"></span>

<p>太阳在天空中位置的变化，哭泣的姑娘滴在叶片上的泪珠，她在埋怨深爱的男孩，远处轨道驶过的火车突然轰鸣的程度和人们梦中惊醒的恼怒，飘动在锅灶和木柴之间忽明忽暗的火苗的燃烧和围在火炉旁人们冰凉的手掌。</p>
<p>卡尔维诺告诉我，”这地方像一块海绵，吸汲着这些不断涌流的记忆的潮水，并随之膨胀着。这些过去被像手纹一样藏起来，它被写在青石板街道的角落，窗口的护栏，楼梯的扶手上。” 除非时光倒流，太阳西升东落，泪水凝固，炊烟消尽，这些痕迹永远在这里。</p>
]]></content>
      <categories>
        <category>读的见的城市</category>
      </categories>
  </entry>
  <entry>
    <title>数组拷贝静态多态</title>
    <url>/2021/10/13/%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h2 id="数组拷贝-静态字段与静态方法-多态"><a href="#数组拷贝-静态字段与静态方法-多态" class="headerlink" title="数组拷贝 静态字段与静态方法 多态"></a>数组拷贝 静态字段与静态方法 多态</h2><hr>
<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><p><strong>在java中有两种数组拷贝的含义</strong></p>
<ol>
<li>引用拷贝，将一个数组变量拷贝到另一个数组变量，这时<strong>两个变量将引用同一个数组</strong></li>
<li>如果希望将一个数组里的所有的值拷贝到一个新的数组当中，需要使用<strong>Arrays</strong>类的<strong>copyof</strong>方法<code>int[] copiedNumbers = Arrays.copyof(numbers,numbers.length)</code>第一个参数是要copy的数组，第二个参数是新数组的长度。这个方法通常用来增加数组的大小。 如果数组元素是数值型，额外的元素被赋值为0.布尔型则被赋值为false。如果新数组的长度比原始数组小，则只拷贝前面的值。</li>
</ol>
<span id="more"></span>

<hr>
<h3 id="静态字段与静态方法"><a href="#静态字段与静态方法" class="headerlink" title="静态字段与静态方法"></a>静态字段与静态方法</h3><p>在java语言中，静态的标志修饰符是static，下面讨论static的几种含义</p>
<ol>
<li>静态字段<br>一个类中，只能将一个字段定义为static。<br>对于非静态实例字段，每个对象都有自己的一个副本。在statiic的修饰下，使得该类的所有实例对象共享一个静态字段。<strong>即使没有该类的对象，静态字段依然存在，它属于类，而不属于任何单个的对象</strong></li>
</ol>
<ul>
<li> 静态常量<br>静态常量比变量更加常用，比如经常用到的<code>System.out</code>，他在System类中声明如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> System</span><br><span class="line">&#123;...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> PrinStream out = ...</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在程序中，可以用类名System.out来访问这个常量。<br>由于每个类的对象都可以修改公共字段，但<strong>公共常量</strong>（即fanal字段）却没问题，out被声明为fanal，所以不允许它重新赋值。</li>
</ul>
<ol start="2">
<li>静态方法<br>静态方法同样属于类，是不在对象上执行的方法。例如Math类的pow方法就是一个静态方法<code>Math.pow(x,a)</code>(计算x的a次方)，pow在完成运算是，并不使用任何Math对象。<strong>换句话说。它没有隐式参数（this）</strong><br>正是由于这一特点，静态方法不能访问非静态的实例字段，因为它不是在对象上执行操作的。但静态方法可以访问静态字段。<br>所以在下面两种情况下可以使用静态方法：</li>
</ol>
<ul>
<li>方法不需要访问对象状态，它所需要的所有参数都痛过显式参数提供（比如Math.pow(x,a)方法里的x，a）。</li>
<li>方法只需要访问类的静态字段。<blockquote>
<p><code>public static void main(String[] args)</code>中，main方法都被标记了static修饰符。这便是一个类中的<strong>静态方法</strong>，main方法不对任何对象进行操作，事实上，在启动程序的时候还没有任何对象。<strong>静态的main方法将执行并构造程序所需要的对象</strong>，每个类都可以有一个main方法，常用于对类进行单元测试。</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>超类对象在任何地方都可以使用子类对象替换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Emloyee staff = <span class="keyword">new</span> Emloyee(...);</span><br><span class="line">Manager boss = <span class="keyword">new</span> Manager(...);</span><br><span class="line">staff = boss(...);</span><br></pre></td></tr></table></figure>
<p>虽然<strong>编译器只将staff看作是一个Emloyee（超类）对象</strong>，但staff和boss事实上引用同一对象new Manager（…)，超类对象已经被子类对象替换。<br>基于这一点，若setBonus是Manager的方法，则可以这样调用<code>boss.setBonus(6000)</code>但不能这样调用<code>staff.setBonus(6000)</code>,因为编译器会根据对象变量创建的初始编译类型来检查是否具有这个方法。   </p>
]]></content>
      <categories>
        <category>Javase笔记</category>
      </categories>
  </entry>
  <entry>
    <title>栈-基本操作</title>
    <url>/2021/05/30/%E6%A0%88-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>总结栈的基本操作和java实现过程中相关知识学习</p>
<span id="more"></span>
<h2 id="栈-辅助栈"><a href="#栈-辅助栈" class="headerlink" title="栈-辅助栈"></a>栈-辅助栈</h2><h3 id="用队列来实现栈"><a href="#用队列来实现栈" class="headerlink" title="用队列来实现栈"></a>用队列来实现栈</h3><blockquote>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。</p>
<p>实现 MyStack 类：</p>
<p>void push(int x) 将元素 x 压入栈顶。<br>          int pop() 移除并返回栈顶元素。<br>          int top() 返回栈顶元素。<br>          boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。</p>
<p>注意：你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</p>
</blockquote>
<p>解题思路：</p>
<p>明确队列的特点使先入先出，栈的特点为先入后出。据此两个队列的作用一目了然。</p>
<p>一个队列为主队列，一个为辅助队列，每次push都需使主队列依次转移至辅助队列，将push的元素压入主队列的队头，达到后入先出的栈的特点。</p>
<p>图解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty()) &#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><hr>
<h2 id="用栈来实现队列"><a href="#用栈来实现队列" class="headerlink" title="用栈来实现队列"></a>用栈来实现队列</h2><blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>
</ul>
</blockquote>
<h3 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h3><blockquote>
<p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>push(x) —— 将元素 x 推入栈中。<br>           pop() —— 删除栈顶的元素。<br>           top() —— 获取栈顶元素。<br>           getMin() —— 检索栈中的最小元素。</p>
</blockquote>
<p>解体思路：</p>
<ul>
<li><p>题目要求基于栈的数据结构，利用栈的特点，避免遍历，应该应用辅助栈法。借用一个辅助栈min_stack，用于存放累计获取的stack中最小值。</p>
</li>
<li><p>算法流程：</p>
<ul>
<li><p>push()方法： 每当push()新值进来时，如果 小于等于 min_stack栈顶值，则一起push()到min_stack，即更新了栈顶最小值；</p>
</li>
<li><p>pop()方法： 判断将pop()出去的元素值是否是min_stack栈顶元素值（即最小值），如果是则将min_stack栈顶元素一起pop()，这样可以保证min_stack栈顶元素始终是stack中的最小值。</p>
</li>
<li><p>top()方法：返回stack栈顶即可。</p>
</li>
<li><p>getMin()方法： 返回min_stack栈顶即可。</p>
</li>
</ul>
</li>
<li><p>min_stack的作用相当于是由stack的栈底开始，不改变其中元素的位置，通过删除元素的方式使其成为一个降序排列的栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; min_stack;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        min_stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//push方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="comment">//通过与辅助栈栈顶的大小比较，判断出是否压入辅助栈</span></span><br><span class="line">        <span class="keyword">if</span>(min_stack.isEmpty() || val &lt;= min_stack.peek())&#123;</span><br><span class="line">            min_stack.push(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pop方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//虽然在if里面，仍然会执行stack栈的pop</span></span><br><span class="line">        <span class="keyword">if</span>(stack.pop().equals(min_stack.peek()))</span><br><span class="line">            min_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>线程的同步</title>
    <url>/2021/07/14/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>线程的生命周期</title>
    <url>/2021/07/14/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>链表-递归</title>
    <url>/2021/05/27/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>总结涉及到递归算法的链表相关基础题</p>
<span id="more"></span>

<h2 id="两两交换链表中的结点"><a href="#两两交换链表中的结点" class="headerlink" title="两两交换链表中的结点"></a>两两交换链表中的结点</h2><blockquote>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<p><img src="/images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/swap_ex1.jpg"></p>
</blockquote>
<h3 id="解1：非递归–多指针"><a href="#解1：非递归–多指针" class="headerlink" title="解1：非递归–多指针"></a>解1：非递归–多指针</h3><p>设置pre指针，实现由temp-start-end到temp-end    start-end.next    ，后重置指针temp的位置即可</p>
<p>画解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置哨兵指针pre</span></span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>); </span><br><span class="line">        pre.next = head; </span><br><span class="line">        <span class="comment">//指针1 temp</span></span><br><span class="line">        ListNode temp = pre;  </span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="keyword">null</span> &amp;&amp; temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//指针2 start</span></span><br><span class="line">            ListNode start = temp.next; </span><br><span class="line">            <span class="comment">// 指针3 end</span></span><br><span class="line">            ListNode end = temp.next.next; </span><br><span class="line">            <span class="comment">//实现两两交换</span></span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;  </span><br><span class="line">            end.next = start;</span><br><span class="line">            temp = start; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解-2：递归"><a href="#解-2：递归" class="headerlink" title="解 2：递归"></a>解 2：递归</h3><p>递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。如图所示，我们应该关注一级调用小单元的情况，也就是单个f(x)。</p>
<p>其中我们应该关心的主要有三点：</p>
<p>1.返回值 </p>
<p>2.调用单元做了什么</p>
<p>3.终止条件</p>
<p>在本题中：</p>
<p>返回值：交换完成的子链表        </p>
<p>调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head（<strong>即所说的不断重复的事</strong>）</p>
<p>完成交换终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换</p>
<p>画解：</p>
<p><img src="/images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/%E9%93%BE%E8%A1%A8%E4%BA%A4%E6%8D%A2.png"></p>
<p><img src="/images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/%E9%80%92%E5%BD%92%E8%BF%87%E7%A8%8B.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件 递归至最后一个执行单元</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//第一个返回值</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每一个小执行单元的过程</span></span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="comment">//返回结果，意义与终止条件中 head相同</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="合并两个有序列表"><a href="#合并两个有序列表" class="headerlink" title="合并两个有序列表"></a>合并两个有序列表</h2><blockquote>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><img src="/images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/merge_ex1.jpg"></p>
</blockquote>
<h3 id="解1：迭代合并"><a href="#解1：迭代合并" class="headerlink" title="解1：迭代合并"></a>解1：迭代合并</h3><p>设置prev指针，通过比较l1和l2的值来调整prev的next指针，随后将prev向后移动一位，循环结束后，直接将非空的一条链表接在后面即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置哨兵指针</span></span><br><span class="line">        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode prev = prehead;</span><br><span class="line">        <span class="comment">//循环迭代</span></span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//prev指针后移</span></span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后接非空的链表</span></span><br><span class="line">        prev.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prehead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解2：递归"><a href="#解2：递归" class="headerlink" title="解2：递归"></a>解2：递归</h3><blockquote>
<p>再次强调：递归本质就是不断重复相同的事情。而不是去思考完整的调用栈，一级又一级，无从下手。<strong>我们应该关注一级调用小单元的情况。</strong></p>
<p><strong>其中我们应该关心的主要有三点：</strong></p>
<p>1.返回值 </p>
<p>2.调用单元做了什么</p>
<p>3.终止条件 </p>
</blockquote>
<p>在本题中:</p>
<p>返回值：合并完成的链表</p>
<p>调用单元：比较l1.val 和l2.val的大小，将小的连接已经合并完的链表</p>
<p>终止条件：l1和l2中有一条为空</p>
<p>画解：</p>
<p><img src="/images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/%E5%90%88%E5%B9%B6.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件和第一个返回值</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h2><blockquote>
<p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>342+465=907:</p>
<p><img src="/images/%E9%93%BE%E8%A1%A8-%E9%80%92%E5%BD%92/addtwonumber1.jpg"></p>
</blockquote>
<h3 id="解1：普通解"><a href="#解1：普通解" class="headerlink" title="解1：普通解"></a>解1：普通解</h3><p>思路：设置两个存放结点值的和一个存放进位值的变量，头节点计算时没有进位值，链表对应位置为空视为存放的值为零。创建新链表，<strong>每个结点的值为sum%10，并传递进位制sum/10</strong>，直到两个链表都循环至空，此时如果还有进位值，需再创建一个结点存放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//准备新链表的指针</span></span><br><span class="line">       ListNode head = <span class="keyword">null</span>,cur = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(l1!= <span class="keyword">null</span>||l2!= <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//链表对应位置为空视为存放的值为零</span></span><br><span class="line">           <span class="keyword">int</span> n = l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">           <span class="keyword">int</span> m = l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">           <span class="comment">//两个值与进位值的和</span></span><br><span class="line">           <span class="keyword">int</span> sum = n+m + inc;</span><br><span class="line">           <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//创建新链表，head和cur同时指向头结点</span></span><br><span class="line">               head = cur = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//调整cur指针，每个结点值为sum%10</span></span><br><span class="line">               cur.next = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>); </span><br><span class="line">               cur = cur.next;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//进位值</span></span><br><span class="line">           inc = sum/<span class="number">10</span>;</span><br><span class="line">           <span class="comment">//迭代进行下一位</span></span><br><span class="line">           <span class="keyword">if</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//如果还有进位值，需再创建一个结点存放</span></span><br><span class="line">       <span class="keyword">if</span>(inc != <span class="number">0</span>)&#123;</span><br><span class="line">           cur.next =  <span class="keyword">new</span> ListNode(inc);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回新链表</span></span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解2：递归-1"><a href="#解2：递归-1" class="headerlink" title="解2：递归"></a>解2：递归</h3><p>效率高但并没有简洁许多。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//记录进位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义终止条件，当l1,l2指针都为null时且进位为0 -&gt;null</span></span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>&amp;&amp;carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当有一条链表为null 且 进位为0时，next指针直接指向另外一条链表返回</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2==<span class="keyword">null</span>&amp;&amp;carry==<span class="number">0</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1==<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>&amp;&amp;carry==<span class="number">0</span>) <span class="keyword">return</span> l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sum = 两链表指针位置上的数字加上进位</span></span><br><span class="line">        <span class="keyword">int</span> sum = (l1==<span class="keyword">null</span>?<span class="number">0</span>:l1.val)+(l2==<span class="keyword">null</span>?<span class="number">0</span>:l2.val)+carry;</span><br><span class="line">        <span class="comment">//计算进位 </span></span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">        <span class="comment">//计算链表的value</span></span><br><span class="line">        <span class="keyword">int</span> value = sum % <span class="number">10</span>;</span><br><span class="line">        ListNode node = <span class="keyword">new</span> ListNode(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归算出这个node的next指向</span></span><br><span class="line">        node.next = addTwoNumbers((l1==<span class="keyword">null</span>?<span class="keyword">null</span>:l1.next),(l2==<span class="keyword">null</span>?<span class="keyword">null</span>:l2.next));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
</search>
